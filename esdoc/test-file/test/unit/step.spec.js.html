<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../">
  <title data-ice="title">test/unit/step.spec.js | Shepherd</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="Guide your users through a tour of your app."><meta property="twitter:card" content="summary"><meta property="twitter:title" content="Shepherd"><meta property="twitter:description" content="Guide your users through a tour of your app."></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./" style="display: flex; align-items: center;"><img src="./image/brand_logo.png" style="width:34px;"></a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  <a href="test.html" data-ice="testLink">Test</a>
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/shipshapecode/shepherd.git"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#js">js</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/js/evented.js~Evented.html">Evented</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/js/modal.js~Modal.html">Modal</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/js/step.js~Step.html">Step</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/js/tour.js~Tour.html">Tour</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-Shepherd">Shepherd</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">test/unit/step.spec.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">import { spy, stub } from &apos;sinon&apos;;
import Shepherd from &apos;../../src/js/shepherd.js&apos;;
import { Step } from &apos;../../src/js/step.js&apos;;
import { Tour } from &apos;../../src/js/tour.js&apos;;
import tippy from &apos;tippy.js&apos;;
import defaultButtons from &apos;../cypress/utils/default-buttons&apos;;

// since importing non UMD, needs assignment
window.Shepherd = Shepherd;

const DEFAULT_STEP_CLASS = &apos;shepherd-step-tooltip&apos;;

describe(&apos;Tour | Step&apos;, () =&gt; {
  describe(&apos;Shepherd.Step()&apos;, () =&gt; {
    const instance = new Shepherd.Tour({
      defaultStepOptions: {
        classes: DEFAULT_STEP_CLASS,
        scrollTo: true
      }
    });

    const testStep = instance.addStep(&apos;test&apos;, {
      attachTo: { element: &apos;body&apos; },
      highlightClass: &apos;highlight&apos;,
      id: &apos;test-id&apos;,
      text: &apos;This is a step for testing&apos;,
      buttons: [
        {
          text: &apos;Next&apos;,
          action: instance.next
        }
      ]
    });

    const showTestStep = instance.addStep(&apos;test2&apos;, {
      buttons: [],
      id: &apos;test2-id&apos;,
      text: &apos;Another Step&apos;
    });

    // Add more steps for total _setupButtons coverage
    instance.addStep(&apos;test3&apos;, {
      buttons: {
        text: &apos;Next&apos;,
        action: instance.next
      },
      id: &apos;test3-id&apos;,
      text: &apos;Another Step part deux&apos;
    });

    const stepWithoutNameWithId = instance.addStep({
      attachTo: { element: &apos;body&apos; },
      highlightClass: &apos;highlight&apos;,
      id: &apos;no-name&apos;,
      text: &apos;This is a step without a name, but with an id&apos;,
      buttons: [
        {
          text: &apos;Next&apos;,
          action: instance.next
        }
      ]
    });

    const stepWithoutNameWithoutId = instance.addStep({
      attachTo: { element:&apos;body&apos; },
      highlightClass: &apos;highlight&apos;,
      text: &apos;This is a step without a name, and without an id&apos;,
      buttons: [
        {
          text: &apos;Next&apos;,
          action: instance.next
        }
      ]
    });

    const beforeShowPromise = new Promise((resolve) =&gt; {
      return setTimeout(1000, resolve(&apos;beforeShowPromise worked!&apos;));
    });

    const beforeShowPromiseTestStep = instance.addStep(&apos;test3&apos;, {
      text: &apos;Before Show Promise Step&apos;,
      beforeShowPromise() {
        return beforeShowPromise;
      }
    });

    beforeEach(() =&gt; {
      tippy.setDefaultProps({ duration: 0, delay: 0 });
    });

    afterEach(() =&gt; {
      instance.complete();
    });

    it(&apos;has all the correct properties&apos;, () =&gt; {
      const values = [&apos;classes&apos;, &apos;scrollTo&apos;, &apos;attachTo&apos;, &apos;highlightClass&apos;, &apos;id&apos;, &apos;text&apos;, &apos;buttons&apos;];
      expect(values).toEqual(Object.keys(testStep.options));

      expect(testStep.id, &apos;passed name set as id&apos;).toBe(&apos;test&apos;);
      expect(stepWithoutNameWithId.id, &apos;no name, id passed is set&apos;).toBe(&apos;no-name&apos;);
      expect(stepWithoutNameWithoutId.id, &apos;id is generated when no name or id passed&apos;).toBe(&apos;step-1&apos;);
    });

    describe(&apos;.hide()&apos;, () =&gt; {
      it(&apos;detaches from the step target&apos;, () =&gt; {
        instance.start();

        const targetElem = document.body;

        expect(targetElem.classList.contains(&apos;shepherd-enabled&apos;)).toBe(true);

        testStep.hide();

        expect(targetElem.classList.contains(&apos;shepherd-enabled&apos;)).toBe(false);
      });
    });

    describe(&apos;.show()&apos;, () =&gt; {
      it(&apos;beforeShowPromise called before `show`&apos;, () =&gt; {
        beforeShowPromiseTestStep.show();

        return beforeShowPromise.then((result) =&gt; {
          expect(result, &apos;beforeShowPromise is called&apos;).toBe(&apos;beforeShowPromise worked!&apos;);
        });
      });

      it(&apos;shows step evoking method, regardless of order&apos;, () =&gt; {
        showTestStep.show();

        expect(document.querySelector(&apos;[data-shepherd-step-id=test2]&apos;)).toBeInTheDocument();
      });
    });
  });

  describe(&apos;bindAdvance()&apos;, () =&gt; {
    let event;
    let link;
    let hasAdvanced = false;

    const advanceOnSelector = &apos;test-selector&apos;;
    const advanceOnEventName = &apos;test-event&apos;;
    const tourProto = {
      next() { hasAdvanced = true; }
    };

    beforeEach(() =&gt; {
      event = new Event(advanceOnEventName);

      link = document.createElement(&apos;a&apos;);
      link.classList.add(advanceOnSelector);
      link.textContent = &apos;Click Me &#x1F44B;&apos;;

      document.body.appendChild(link);
    });

    afterEach(() =&gt; {
      link.remove();
    });

    it(&apos;triggers the `advanceOn` option via object&apos;, () =&gt; {
      const step = new Step(tourProto, {
        advanceOn: { selector: `.${advanceOnSelector}`, event: advanceOnEventName }
      });

      step.isOpen = () =&gt; true;

      step.bindAdvance();
      link.dispatchEvent(event);

      expect(link.classList.contains(advanceOnSelector)).toBe(true);
      expect(hasAdvanced, &apos;`next()` triggered for advanceOn&apos;).toBe(true);
    });

    it(&apos;captures events attached to no element&apos;, () =&gt; {
      const step = new Step(tourProto, {
        advanceOn: { event: advanceOnEventName }
      });

      step.isOpen = () =&gt; true;

      step.bindAdvance();
      document.body.dispatchEvent(event);

      expect(hasAdvanced, &apos;`next()` triggered for advanceOn&apos;).toBeTruthy();
    });

    it(&apos;should support bubbling events for nodes that do not exist yet&apos;, () =&gt; {
      const event = new Event(&apos;blur&apos;);

      const step = new Step(tourProto, {
        text: &apos;Lorem ipsum dolor: &lt;a href=&quot;https://example.com&quot;&gt;sit amet&lt;/a&gt;&apos;,
        advanceOn: {
          selector: &apos;a[href=&quot;https://example.com&quot;]&apos;,
          event: &apos;blur&apos;
        }
      });

      step.isOpen = () =&gt; true;

      step.bindAdvance();
      document.body.dispatchEvent(event);

      expect(hasAdvanced, &apos;`next()` triggered for advanceOn&apos;).toBeTruthy();
    });

    it(&apos;calls `removeEventListener` when destroyed&apos;, function(done) {
      const bodySpy = spy(document.body, &apos;removeEventListener&apos;);
      const step = new Step(tourProto, {
        advanceOn: { event: advanceOnEventName }
      });

      step.isOpen = () =&gt; true;

      step.bindAdvance();
      step.trigger(&apos;destroy&apos;);

      expect(bodySpy.called).toBe(true);
      bodySpy.restore();

      done();
    });
  });

  describe(&apos;bindButtonEvents()&apos;, () =&gt; {
    const link = document.createElement(&apos;a&apos;);
    const step = new Step(new Tour(), {});
    it(&apos;adds button events&apos;, () =&gt; {
      const event = new Event(&apos;test&apos;);
      const hover = new Event(&apos;mouseover&apos;);
      let eventTriggered = false;

      step.bindButtonEvents({
        events: {
          &apos;mouseover&apos;: &apos;1&apos;,
          test: () =&gt; eventTriggered = true
        },
        text: &apos;Next&apos;,
        action: () =&gt; {}
      }, link);

      link.dispatchEvent(event);
      link.dispatchEvent(hover);
      expect(eventTriggered, &apos;custom button event was bound/triggered&apos;).toBeTruthy();
    });

    it(&apos;removes events once destroyed&apos;, () =&gt; {
      step.destroy();

      expect(link.hasAttribute(&apos;data-button-event&apos;), &apos;attribute to confirm event is removed&apos;).toBeFalsy();
    });

  });

  describe(&apos;bindCancelLink()&apos;, () =&gt; {
    it(&apos;adds an event handler for the cancel button&apos;, () =&gt; {
      const event = new MouseEvent(&apos;click&apos;, {
        view: window,
        bubbles: true,
        cancelable: true
      });
      const link = document.createElement(&apos;a&apos;);
      const step = new Step();
      let cancelCalled = false;

      step.cancel = () =&gt; cancelCalled = true;
      step.bindCancelLink(link);

      link.dispatchEvent(event);
      expect(cancelCalled, &apos;cancel method was called from bound click event&apos;).toBeTruthy();
    });
  });

  describe(&apos;bindMethods()&apos;, () =&gt; {
    it(&apos;binds the expected methods&apos;, () =&gt; {
      const step = new Step();
      const methods = [
        &apos;_show&apos;,
        &apos;cancel&apos;,
        &apos;complete&apos;,
        &apos;destroy&apos;,
        &apos;hide&apos;,
        &apos;isOpen&apos;,
        &apos;scrollTo&apos;,
        &apos;setupElements&apos;,
        &apos;show&apos;
      ];
      methods.forEach((method) =&gt; {
        expect(step[method], `${method} has been bound`).toBeTruthy();
      });
    });
  });

  describe(&apos;cancel()&apos;, () =&gt; {
    it(&apos;triggers the cancel event and tour method&apos;, () =&gt; {
      let cancelCalled = false;
      let eventTriggered = false;
      const step = new Step({
        cancel() {
          cancelCalled = true;
        }
      });
      step.on(&apos;cancel&apos;, () =&gt; eventTriggered = true);
      step.cancel();

      expect(cancelCalled, &apos;cancel method from tour called&apos;).toBeTruthy();
      expect(eventTriggered, &apos;cancel event was triggered&apos;).toBeTruthy();
    });
  });

  describe(&apos;complete()&apos;, () =&gt; {
    it(&apos;triggers the complete event and tour method&apos;, () =&gt; {
      let completeCalled = false;
      let eventTriggered = false;
      const step = new Step({
        complete() {
          completeCalled = true;
        }
      });
      step.on(&apos;complete&apos;, () =&gt; eventTriggered = true);
      step.complete();

      expect(completeCalled, &apos;complete method from tour called&apos;).toBeTruthy();
      expect(eventTriggered, &apos;complete event was triggered&apos;).toBeTruthy();
    });
  });

  describe(&apos;destroy()&apos;, () =&gt; {
    it(&apos;triggers the destroy event&apos;, () =&gt; {
      const step = new Step();
      let eventTriggered = false;
      step.on(&apos;destroy&apos;, () =&gt; eventTriggered = true);
      step.destroy();

      expect(eventTriggered, &apos;destroy event was triggered&apos;).toBeTruthy();
    });
  });

  describe(&apos;hide()&apos;, () =&gt; {
    let beforeHideTriggered = false;
    let modalHideCalled = false;
    const step = new Step({
      modal: {
        hide() {
          modalHideCalled = true;
        }
      }
    });

    it(&apos;triggers the before-hide event&apos;, () =&gt; {
      step.on(&apos;before-hide&apos;, () =&gt; beforeHideTriggered = true);
      step.hide();

      expect(beforeHideTriggered, &apos;before-hide event was triggered&apos;).toBeTruthy();
    });

    it(&apos;calls tour.modal.hide&apos;, () =&gt; {
      expect(modalHideCalled, &apos;tour.modal.hide called&apos;).toBeTruthy();
    });
  });

  describe(&apos;parseAttachTo()&apos;, function() {
    it(&apos;fails if element does not exist&apos;, function() {
      const step = new Step({}, {
        attachTo: { element: &apos;.scroll-test&apos;, on: &apos;center&apos; }
      });

      const { element } = step.parseAttachTo();
      expect(element).toBeFalsy();
    });
  });

  describe(&apos;setupElements()&apos;, () =&gt; {
    it(&apos;calls destroy on the step if the content element is already set&apos;, () =&gt; {
      const step = new Step();
      let destroyCalled = false;
      step.el = document.createElement(&apos;a&apos;);
      step.destroy = () =&gt; destroyCalled = true;
      step.setupElements();
      expect(destroyCalled, &apos;setupElements method called destroy with element set&apos;).toBeTruthy();
    });

    it(&apos;calls destroy on the tooltip if it already exists&apos;, () =&gt; {
      const step = new Step();
      let destroyCalled = false;
      step.tooltip = {
        destroy() { destroyCalled = true; }
      };
      step.setupElements();
      expect(destroyCalled, &apos;setupElements method called destroy on the existing tooltip&apos;).toBe(true);
    });

    it(&apos;calls bindAdvance() if advanceOn passed&apos;, () =&gt; {
      const step = new Step({
        next: () =&gt; true
      }, {
        advanceOn: { selector: &apos;.click-test&apos;, event: &apos;test&apos; }
      });
      const bindFunction = spy(step, &apos;bindAdvance&apos;);
      step.setupElements();

      expect(bindFunction.called).toBeTruthy();
    });
  });

  describe(&apos;scrollTo()&apos;, () =&gt; {
    it(&apos;calls the scroll native method&apos;, () =&gt; {
      const div = document.createElement(&apos;div&apos;);
      let handlerCalled = false;
      div.classList.add(&apos;scroll-test&apos;);
      document.body.appendChild(div);
      const step = new Step(&apos;test&apos;, {
        attachTo: { element: &apos;.scroll-test&apos;, on: &apos;center&apos; }
      });
      div.scrollIntoView = () =&gt; handlerCalled = true;

      step.scrollTo();
      expect(handlerCalled).toBeTruthy();
    });

    it(&apos;calls the custom handler&apos;, () =&gt; {
      let handlerAdded = false;
      const step = new Step(&apos;test&apos;, {
        scrollToHandler: () =&gt; handlerAdded = true
      });

      step.scrollTo();
      expect(handlerAdded).toBeTruthy();
    });
  });

  describe(&apos;setOptions()&apos;, () =&gt; {
    it(&apos;calls event handlers passed in as properties to the `when` option&apos;, () =&gt; {
      let whenCalled = false;
      const step = new Step(&apos;test&apos;, {
        when: {
          destroy: () =&gt; whenCalled = true
        }
      });

      step.destroy();
      expect(whenCalled).toBeTruthy();
    });
  });

  describe(&apos;getTour()&apos;, () =&gt; {
    it(&apos;returns the tour value&apos;, () =&gt; {
      const step = new Step(new Shepherd.Tour());

      expect(step.getTour() instanceof Shepherd.Tour).toBeTruthy();
    });

  });

  describe(&apos;_addContent()&apos;, () =&gt; {
    it(&apos;adds plain text to the content&apos;, () =&gt; {
      const content = document.createElement(&apos;div&apos;);
      const step = new Step();
      step.options.text = &apos;I am some test text.&apos;;

      step._addContent(content);

      expect(content.querySelector(&apos;.shepherd-text&apos;).innerHTML).toBe(&apos;I am some test text.&apos;);
    });

    it(&apos;applies HTML element directly to content&apos;, () =&gt; {
      const content = document.createElement(&apos;div&apos;);
      const text = document.createElement(&apos;p&apos;);
      const step = new Step();
      text.innerHTML = &apos;I am some test text.&apos;;
      step.options.text = text;

      step._addContent(content);

      expect(content.querySelector(&apos;.shepherd-text&apos;).innerHTML).toBe(&apos;&lt;p&gt;I am some test text.&lt;/p&gt;&apos;);
    });

    it(&apos;applies the text from a function&apos;, () =&gt; {
      const content = document.createElement(&apos;div&apos;);
      const step = new Step();
      step.options.text = () =&gt; &apos;I am some test text.&apos;;

      step._addContent(content);

      expect(typeof step.options.text === &apos;function&apos;).toBeTruthy();
      expect(content.querySelector(&apos;.shepherd-text&apos;).innerHTML).toBe(&apos;I am some test text.&apos;);
    });
  });

  describe(&apos;_addButtons&apos;, () =&gt; {
    it(&apos;renders no buttons if an empty array is passed to `options.buttons`&apos;, () =&gt; {
      const content = document.createElement(&apos;div&apos;);
      const step = new Step();

      step.options.buttons = [];

      step._addButtons(content);

      expect(content.children.length).toBe(0);
    });

    it(&apos;renders no buttons if nothing is passed to `options.buttons`&apos;, () =&gt; {
      const content = document.createElement(&apos;div&apos;);
      const step = new Step();

      step._addButtons(content);

      expect(content.children.length).toBe(0);
    });

    it(&apos;renders buttons for each item passed to `options.buttons`&apos;, () =&gt; {
      const content = document.createElement(&apos;div&apos;);
      const step = new Step();

      step.options.buttons = [
        defaultButtons.cancel,
        defaultButtons.next
      ];

      step._addButtons(content);

      expect(content.children.length).toBe(1);

      const buttonContainer = content.querySelector(&apos;.shepherd-footer&apos;);

      expect(buttonContainer instanceof HTMLElement).toBe(true);

      const buttons = buttonContainer.querySelectorAll(&apos;.shepherd-button&apos;);

      expect(buttons.length).toBe(2);
    });
  });

  describe(&apos;_addKeyDownHandler&apos;, () =&gt; {
    it(&apos;ESC cancels the tour&apos;, () =&gt; {
      const element = document.createElement(&apos;div&apos;);
      const step = new Step();

      const cancelStub = stub(step, &apos;cancel&apos;);

      step._addKeyDownHandler(element);

      const event = new KeyboardEvent(&apos;keydown&apos;, { keyCode: 27 });
      element.dispatchEvent(event);

      expect(cancelStub.called).toBe(true);
      cancelStub.restore();
    });

    it(&apos;arrow keys move between steps&apos;, () =&gt; {
      const element = document.createElement(&apos;div&apos;);
      const tour = new Tour();
      const step = new Step(tour, {});

      const tourBackStub = stub(tour, &apos;back&apos;);
      const tourNextStub = stub(tour, &apos;next&apos;);

      expect(tourBackStub.called).toBe(false);
      expect(tourNextStub.called).toBe(false);

      step._addKeyDownHandler(element);

      const rightArrowEvent = new KeyboardEvent(&apos;keydown&apos;, { keyCode: 39 });
      element.dispatchEvent(rightArrowEvent);

      expect(tourNextStub.called).toBe(true);


      const leftArrowEvent = new KeyboardEvent(&apos;keydown&apos;, { keyCode: 37 });
      element.dispatchEvent(leftArrowEvent);

      expect(tourBackStub.called).toBe(true);

      tourBackStub.restore();
      tourNextStub.restore();
    });
  });

  describe(&apos;_addCancelLink&apos;, () =&gt; {
    it(&apos;Cancel link&apos;, () =&gt; {
      const header = document.createElement(&apos;header&apos;);
      const element = document.createElement(&apos;div&apos;);
      const step = new Step(null, { showCancelLink: true });

      const cancelLinkStub = stub(step, &apos;bindCancelLink&apos;);

      step._addCancelLink(element, header);

      expect(cancelLinkStub.called).toBe(true);
      expect(element).toHaveClass(&apos;shepherd-has-cancel-link&apos;);
      cancelLinkStub.restore();
    });
  });

  describe(&apos;_createTooltipContent&apos;, () =&gt; {
    it(&apos;ARIA attributes set&apos;, () =&gt; {
      const step = new Step(null, {
        id: &apos;test-step&apos;,
        text: &apos;Lorem Ipsum&apos;,
        title: &apos;Test&apos;
      });

      const element = step._createTooltipContent();

      expect(element.getAttribute(&apos;aria-labeledby&apos;)).toBe(&apos;test-step-label&apos;);
      expect(element.querySelector(&apos;.shepherd-title&apos;).id).toBe(&apos;test-step-label&apos;);

      expect(element.getAttribute(&apos;aria-describedby&apos;)).toBe(&apos;test-step-description&apos;);
      expect(element.querySelector(&apos;.shepherd-text&apos;).id).toBe(&apos;test-step-description&apos;);
    });
  });
});
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
